# PostgreSQL 配置文件


```
pgsql 参数文件:
1. postgresql.conf : 静态参数文件, 必须编辑后重启实例
2. postgresql.auto.conf : 动态参数文件, 实例中修改后, 自动刷新到该文件。 不推荐手动修改。 由实例维护, ALTER SYSTEM 命令修改的参数将保存在该文件
3. postgresql.conf.user : 用户自定义, 必须在 postgresql.conf 指定要使用该文件, 才会生效

动态参数: 修改完立即生效
静态参数: 重启后生效
分类: 管理员可修改, 普通用户可修改
```

## 配置文件

### 主机授权配置文件: `pg_hba.conf`

> 修改 `pg_hba.conf` 授权文件后, 执行 `pg_ctl reload` 或 `SELECT pg_reload_conf();` 生效

#### pg_hba.conf 配置文件示例

```
# TYPE	DATABASE	USER    	ADDRESS     	METHOD
local 	all     	postgres	            	scram-sha-256
host  	all     	postgres	127.0.0.1/32	scram-sha-256
```

#### pg_hba.conf 配置文件说明

`TYPE`:  指定访问的网络协议
- `local`:  socket 方式连接
- `host`:   TCP/IP 连接
- `hostssl`: TCP/IP并且需要SSL加密方式连接

`DATABASE`: 指定要访问的数据库名
- `dbname`:  指定允许访问的数据库名
- `all`:     指定允许访问所有数据库
- `replication`: 主备复制时需要单独添加的授权

`USER`: 指定要访问实例的 PG 
- `username`: 指定用户
- `all`:      所有用户
- `+group_name`:  表示一组用户
- `@file_name`:   表示文件中包含的用户列表

`ADDRESS`:
- `127.0.0.1/32`  客户端IP地址
- `0.0.0.0/0`    所有地址都可以访问
- `hostname`      客户端主机名(hosts文件中包含)
- `ip_addr/net_mask`  表示指定的IP网段

`METHOD`:
- `trust`: 信任, 无需密码
- `scram-sha-256`:  sha256 加密密码, 当前最安全的一种(2024)
- `md5`:      md5 加密密码
- `password`: 以明文形式发送口令
- `ident`:    请求发起者的操作系统用户映射为 PostgreSQL 数据库内部用户
		 并以该内部用户的权限登录, 无需密码。
		 操作系统用户与PGSQL内部用户之前的映射关系记录在 pg_ident.conf 文件
- `peer`:     使用连接发起端的操作系统名进行身份验证, 仅限于: Linux, BSD, Mac OS X, Solaris
- `reject`:        拒绝请求

### 系统用户与 PG 用户映射: `pg_ident.conf`

在 pg_hba.conf 中如果设置了 `ident` 方式访问数据库, 则需要在 `pg_ident.conf` 文件中完成 系统用户与 PG 用户映射关系的  

### 用户配置文件: postgresql.conf.user

 用户自定义, 必须在 `postgresql.conf` 指定要该文件的路径, 才会生效

### 动态配置文件: postgresql.auto.conf

动态参数文件, 实例中修改后, 自动刷新到该文件。  
不推荐手动修改。 由实例维护, ALTER SYSTEM 命令修改的参数将保存在该文件  

#### postgresql.conf.user 配置文件示例

```
# Do not edit this file manually!
# It will be overwritten by the ALTER SYSTEM command.
```

### PG实例配置文件: postgresql.conf

> 修改 `postgresql.conf` 文件中的参数
> 有一些参数可以执行 `pg_ctl reload` 或 `SELECT pg_reload_conf();` 生效
> 但有些参数修改后必须重启PGSQL 实例

#### postgresql.conf.user 配置文件示例

```toml
listen_addresses                 = '*'
port                             = 5432
unix_socket_directories          = '/tmp/'
timezone                         = 'Asia/Shanghai'
shared_buffers                   = 512MB
temp_buffers                     = 8MB
work_mem                         = 8MB
huge_pages                       = off
effective_cache_size             = 8GB
maintenance_work_mem             = 64MB
max_connections                  = 5000
max_prepared_transactions        = 1000  # 最大预处理事务数
superuser_reserved_connections   = 10    # 最大连接数满了之后, 超级管理员的保留连接数
tcp_keepalives_idle              = 120
tcp_keepalives_interval          = 10
tcp_keepalives_count             = 10
authentication_timeout           = 10s
wal_level                        = replica  # wal 日志类型, logical, archive
wal_buffers                      = 32MB
wal_log_hints                    = on
min_wal_size                     = 256MB
max_wal_size                     = 50GB
wal_keep_size                    = 50GB
max_slot_wal_keep_size           = 50GB
commit_delay                     = 10     # wal 延迟刷盘, 等其他事务一块刷盘(微秒)
commit_siblings                  = 5      # 有几个并发事务才会启用 wal 延迟刷盘机制
full_page_writes                 = on     # 是否开启全页写
synchronous_commit               = on     # wal 写到磁盘文件再返回请求响应
synchronous_standby_names        = ''     # 实时同步时, 在主库配置该参数. 写备库名列表
max_wal_senders                  = 20     # 最大 walsender 进程数量
hot_standby                      = on     # 作为备库时, 是否允许只读
wal_sender_timeout               = 60     # 备库接收进程超时时间, 默认 60 秒
max_standby_streaming_delay      = 30s    # 流复制最大延迟
wal_receiver_status_interval     = 10s    # 向主库报告状态的最大间隔时间
hot_standby_feedback             = on     # 查询冲突时向主库反馈
fsync                            = on     # 确保 wal 刷盘
bgwriter_delay                   = 200    # 后台写进程多长时间唤醒一次(200ms)
bgwriter_lru_maxpages            = 100    # 后台进程每次最多刷新多少个块
checkpoint_timeout               = 300    # 检查点间隔时间
checkpoint_completion_target     = 0.5    # 检查点完成基于间隔时间的百分比
logging_collector                = on
log_destination                  = 'csvlog'
log_directory                    = '/opt/pgsql5432/data/log'
log_filename                     = 'postgresql-%a.log'
log_rotation_age                 = 1d
log_duration                     = off
log_truncate_on_rotation         = on
log_min_duration_statement       = 60000
log_autovacuum_min_duration      = -1    # 记录 autovacuum 什么时候操作了哪些表。
log_checkpoints                  = off
log_connections                  = off
log_disconnections               = off
log_lock_waits                   = off
log_statement                    = none
log_line_prefix                  = '%t [%p]: user=%u,db=%d,client=%h '
log_timezone                     = 'Asia/Shanghai'
log_min_messages                 = 'error'
log_min_error_statement          = 'error'
client_min_messages              = 'error'
# shared_preload_libraries       = 'timescaledb'

# pg_stat_statements 插件参数
shared_preload_libraries         = 'pg_stat_statements'
pg_stat_statements.max           = 10000
pg_stat_statements.track         = all
pg_stat_statements.track_utility = off
pg_stat_statements.save          = off

# 并行查询相关
# 如果 SQL 中没有聚合函数, 则不会触发并行处理
max_worker_processes             = 8
max_parallel_workers_per_gather  = 2
min_parallel_table_scan_size     = 1024
min_parallel_index_scan_size     = 64
parallel_setup_cost              = 1000
parallel_tuple_cost              = 0.1

# auto vacuum 相关参数
# 这两个参数控制是否启用 autovacuum, 生产环境不能关闭
autovacuum                       = on
track_counts                     = on
autovacuum_naptime               = 60   # 多久执行一次, 默认1分钟
autovacuum_max_workers           = 3    # 执行 autovacuum 的工作进程数量
vacuum_freeze_min_age            = 50000000   # 惰性冻结
vacuum_freeze_table_age          = 150000000  # 急性冻结

# 触发 autovacuum 条件
autovacuum_vacuum_threshold      = 50  # 下面因子计算完要加上这个权重
autovacuum_vacuum_scale_factor   = 0.2 # 表中死元组占比超过该值, 触发自动 vacuum
autovacuum_analyze_threshold     = 50  # 下面因子计算完要加上这个权重
autovacuum_analyze_scale_factor  = 0.1 # 表中被改写数据占比超过该值, 触发自动 analyze

# autovacuum 对I/O的影响, 由以下几个参数控制
autovacuum_vacuum_cost_limit     = -1 # 每次 autovacuum 使用的资源
autovacuum_vacuum_cost_delay     = 2  # 当 autovacuum 达到资源限制时, 睡眠多久(20ms)
vacuum_cost_page_hit             = 1  # 读共享缓冲区中的页需要的成本(1)
vacuum_cost_page_miss            = 10 # 读不在共享缓冲区中的页需要的成本(10)
vacuum_cost_page_dirty           = 20 # 在每一页中发现死元组时写入该页需要的成本(20)
```

#### postgresql.conf 配置文件说明

- work_mem
	- 默认: 4MB - 线程独享
	- 建议实例级设置默认值, 特殊连接在会话级单独设置
	- 如果设置  4MB, 每一个连接会话都会占用 4MB
	- 每个会话在进行 order by, distinct, merge-join, hash-join 等操作时可用的最大内存
	- 主要用于写入临时文件之前内部排序操作和散列表使用的内存量
	- 线程独占, 即假设你设置为30MB，则40个用户同时执行查询排序，很快就会使用1.2GB的实际内存
	- 对于  OLTP 系统, 并发很多的简单SQL, 设置 16MB 完全够用
	- 对于 OLAP 系统, 复杂的查询频率比较低的SQL, 可以设置 256M
	- 也可以在查询之前在会话级别设置该参数
	- 此参数如果设置过大, 相应的 max_connections 应该减少, 避免真出现同时所有连接全都执行大排序操作, 导致内存崩溃
	
- maintenance_work_mem
	- 默认: 64MB - 线程独享
	- 建议实例级设置默认值, 特殊连接在会话级单独设置
	- 在执行 vacuum, restore, create index, add foreign key, alter table 等任务时使用

- temp_buffers
	- 默认:  - 线程独享
	- 每个会话使用的最大临时缓冲区

- shared_buffers
	- 共享缓冲区,  建议设置为物理内存的 1/4
	- PostgreSQL使用自己的缓冲区(shared_buffers)，也使用Linux操作系统内核缓冲OS Cache，这就说明数据两次存储在内存中

- wal_buffer
	- wal 日志缓冲区, 建议设置 16MB 左右, 如果事务非常繁忙, 可以适当调大

- effective_cache_size  
	- 默认: 4G, 建议使用默认值
	- 也可以设置到 pgsql 实际可用内存的 50% 到 75%	- 
	- 值越高, 优化器越倾向于走索引。
	- 提供一个可用于磁盘缓存的内存量的估量, 它只是一个建议值, 不会实际分配内存。 

- fsync
	- 默认: on
	- 确保 wal 数据写到磁盘 `fsync()`, 才响应成功
	- 如果关闭, 在发生故障时, 可能会导致数据丢失

- synchronous_commit
	- 事务是否等待 wal 写入磁盘，再返回给客户端成功
	-  off  关闭， 不等待 wal 写入磁盘
	-  on  默认, wal 确认写到磁盘再响应成功
	-  local  
	-  remote_write 等待流复制的备节点收到 wal 日志并写入备节点 wal buffer 缓存
	-  remote_apply 等待流复制的备节点收到 wal 日志, 并将 wal 日志写入磁盘, 并完成事务回放 

- synchronous_standby_names
	- 备库名称, 如果设置了该参数, 则 `synchronous_commit` 参数也将等待备库生效
	- 设置 `synchronous_standby_names` 后, `synchronous_commit` 参数的值作用:
	- on: 等待 wal 写入到备库
	- remote_write:  等待 wal 写到备节点, 但不等备节点刷盘
	- on: 如果有备库, 备库wal刷盘后返回
	- remote_apply: 等待 wal 在备库刷完盘, 然后完成 apply 重放, 才响应
	- 
- checkpoint_timeout
	- 默认: 300
	- 间隔多长时间产生一次检查点
	- 如果每次检查点操作要刷盘的数据块太多, 会导致磁盘IO压力比较大, 影响数据库性能
	- 设置时间长一点, 会减少磁盘IO, 提高性能, 但会延长数据库崩溃时的恢复时间
	- 
- checkpoint_completion_target
	- 默认: 0.5
	- 每次的检查点操作完成的时长 与 每次检查点时间间隔的比例。
	- 值范围 0 ~ 1, 默认 0.5 即默认 150 秒完成
	- 如果设置 0.7, 并且每 300 秒产生一次检查点. 每次检查点操作要在 300 * 0.7 = 210 秒完成。

- full_page_writes
	- 默认: on
	- 把数据块整个写入到WAL日志中, 是为了解决块不一致问题，保护数据的完整性
	- 全页写会导致WAL日志膨胀, 增加额外I/O
	- 如果文件系统能够实现 阻止部分写情况(不允许出现写半个数据块的情况), 则 pgsql 可以禁用全页写功能
	- 全页写模式:
	- 1. 非强制模式:
	- 	- 最近一次检查点之后, 第一次修改的数据块会进行全页写, 在下一次检查点之前, 第二次开始, 之后的多次修改这一数据块改为记录事务到wal日志.  直到下一次检查点。
	- 2. 强制模式:
	- 	- 当用 pg_basebackup 备份时, 会自动执行强制模式, 备份期间, 被修改的数据块会全部写入WAL中。 (pg_basebackup 会自动调用 pg_start_backup() 函数)
	- 3. 当执行 pg_start_backup() 函数时, 系统也会进入全页写模式。 执行 pg_stop_backup() 函数关闭全页写模式

- max_connections
	- 最大连接数
	-  最大连接数， 根据历史连接最大值判断, 一般不建议超过1000

- superuser_reserved_connections
	- 最大连接数满了之后, 超级管理员的保留连接数

- min_wal_size
	- 默认: 

- max_wal_size
	- 默认: 1GB
	- 保留的 wal 日志最大大小

- wal_keep_size
	- 保持与 max_wal_size 一致

- wal_keep_segments
	- 已经废弃
	- PG 13 之前的参数, 现在已经被 wal_keep_size 代替
	- 保留的 wal 日志文件个数, 建议 wal 文件个数* 16MB = max_wal_size

- max_worker_processes
	- 如果 SQL 中没有聚合函数, 则不会触发并行处理
	- 设置 PG 实例 workers 的最大数量, 此参数不能超过主机上实际的CPU核数
	- 
- max_paraller_workers
	- 已经弃用
	- 并行池中 workers 最大数量, 建议和 `max_worker_processes` 保持一致

- max_parallel_workers_per_gather
	- 每个SQL操作可以使用的 workers 最大数量,  建议不超过 `max_paraller_workers` 的三分之一

- min_parallel_table_scan_size
	- 每个  worker 最小扫描的 table 大小。 
	- 实际每一个 worker 的增加都会在上一个 worker 扫描的基础上增加 3 倍。
	- 比如: 该参数设置 100MB, 则 100 MB 以内会使用 1 worker,  300MB以内使用 2 worker, 900MB 以内使用 3 worker， 2700MB 以内使用 4 worker, 8100MB 以内的数据扫描使用 5 worker 

- min_parallel_index_scan_size
	- 每个  worker 最小扫描的 index 大小。 实际是每超过该参数值的3倍才会多使用一个 worker
	- 实际效果同 `min_parallel_table_scan_size`

- parallel_setup_cost
	- 当查询成本累计时间超过该值时, 才使用并行查询

- parallel_tuple_cost
	- 默认: 0.1
	- 优化器从一个 worker 传递记录到另一个 woker 的代价
	- 
- vacuum_freeze_min_age
	- 惰性冻结使用, 默认 5千万, 超过这个值的事务将被冻结
	- 当前事物ID为: 2000,   vacuum_freeze_min_age 设置为: 1600
	- 则 2000 - 1600 = 400 , 则小于 400 的事务ID将会被冻结

- vacuum_freeze_table_age
	- 急性冻结使用, 默认1亿5千万

- log_autovacuum_min_duration
	- 记录 autovacuum 什么时候做, 操作了哪些表。默认 -1 不记录
	- -1 表示不记录
	- 0 表示记录所有的
	- 250ms, 1s, 1min, 1h, 1d  表示只记录 vacuum 的时间超过该值的操作

- bgwriter_delay
	- 后台写进程多长时间唤醒一次, 默认 200 毫秒
	- 
- bgwriter_lru_maxpages
	- 后台进程每次最多刷新多少个块, 默认 100 个块


- toast_max_chunk_size
	- 最新版本找不到这参数了
	- 最大的 chunk 大小, 默认 2KB
	- 
- toast_tuple_target
	- 最新版本找不到这参数了
	- toast压缩或移动超过该值的部分, 默认 2KB

### 暂时未整理的参数

```
# 这些参数和业务使用有关

wal_level=logical
max_replication_slots=64
max_wal_senders=64
max_logical_replication_workers=64
wal_sender_timeout = 180s
wal_keep_segments=200
```