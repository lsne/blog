# pg_auto_failover 高可用测试

### 结论

```
普通场景:
	pg_auto_failover 正常情况下会保证有1个从节点强制同步, 理论上不会出现从节点延迟的情况; 
特殊情况下, 比如从节点故障时间较长, 启动之后, 如果已经不能正常同步主节点, 或者由于从库刚启动需要一定时间同步主节点数据导致的有延迟情况, 这时如果主节点故障, 则 pg_auto_failover 不会切主, 客户端的所有操作都将会写入失败。

关于实例故障, 但机器正常的场景:
   pg_auto_failover 本身没有做对于主机的探测功能, 只对 pgsql 实例进行探测(通过是否可以使用 libpq.so 与 pgsql 的 5432 端口正常建立连接判断是否正常), 只要monitor节点连接到主库失败, 就会产生切主操作
```

### pg_auto_failover 工作原理

#### 进程说明

pg_auto_failover 最小集群会有以下3个实例进程

- pgsql 主节点
	-  承接客户端的读写请求

- pgsql 从节点
	-  实时同步 pgsql 主节点的数据,  在主库故障时, 可变为主节点
	- 必要情况下, 客户端通过连接参数也可以将读请求发送到该pgsql从节点

- monitor 节点
	-  负责监控 pgsql 主节点和pgsql 从节点的状态, 如果主节点实例异常, 还负责将从节点切为主库。

其中 `pgsql 主节点` 和 `pgsql 从节点` 不是使用原生的 `pg_ctl` 或 `postgres` 命令启动, 而是通过 pg_auto_failover 自定义的插件命令 `pg_autoctl` 命令启动,  `pg_autoctl` 命令首先会启动一个主进程, 然后会将 原生的 `postgres` 进程作为子进程来启动。主进程的作用:
	1. 循环检查本地实例的当前预期状态并报告给 `monitor` 节点
	2. 从 `monitor` 接收状态请求, 并对本地实例当前状态和接收到的 `monitor` 指定的状态不一致时做相应的处理操作
	3. 维护本地状态, 包括与监视器和其组的其他 PostgreSQL 节点建立的最新通信，使其能够检测网络分区。`monitor` 使用`这组信息`及其`自身的健康检查信息`来驱动状态机并为守护者分配目标状态

#### 同步机制

```toml
# pg_auto_failover 主从同步设置了以下参数:

# 以下参数保证了数据同步机制, 即客户端请求要保证至少写入到 1 个从节点上, 才给客户端返回操作完成
synchronous_standby_names = "ANY 1 (pgautofailover_standby_2)"

# 以下参数 和上面 synchronous_standby_names 参数结合, 保证了至少要有 1 个从节点接收到 wal 日志并将 wal 日志写入到磁盘文件, 才给客户端返回操作完成
synchronous_commit   = on
```

#### 探活检测机制

```
monitor 节点会定期连接到所有数据节点以查看它们是否健康 (通过 libpq.so 对 5432 端口建立连接, 连接成功则判定为实例正常)

以下为 monitor 探活检查的相关参数以及默认值, monitor 每5秒对数据节点进行一次健康检查, 如果检查失败, 会每隔2秒重试一次, 重试 2 次(加上第1次一共检查探测3次)还是失败,则进行切主流程。 每次检查以及重试检查时, 发送的连接请求最多等5秒, 5秒还没有应答则直接标记为超时,连接检查失败。

pgautofailover.health_check_period = 5000       # monitor 对数据节点进行探测间隔时间  
pgautofailover.health_check_retry_delay = 2000  # 探测失败后每次重试时间间隔
pgautofailover.health_check_max_retries = 2     # 探测失败后重试次数
pgautofailover.health_check_timeout = 5000      # libpq 建立连接超时时间
```

### 高可用故障测试

> 测试时模拟写入场景是使用 go 语言使用 `gorm` 单线程写入
> 连接串(DSN): `"host='1.1.1.1,2.2.2.2' port=5432 user=pguser password=123456 dbname=pguser sslmode=disable TimeZone=Asia/Shanghai target_session_attrs=read-write"`

#### pgsql 主节点故障

> 模拟主节点故障

```sh
systemctl stop pgdata5432
```

> 测试结果

```
所有写请求都会执行失败, 50秒后, 将从节点提升为主库。 客户端开始写入成功

老主库重新启动后, 自动做为新主库的从节点, 同步新主库数据
```

#### pgsql 从节点故障

> 模拟从节点故障

```sh
systemctl stop pgdata5432
```

> 测试结果

```
应用程序写入请求阻塞(卡住了), 等待20秒之后将 synchronous_standby_names 参数置空, 即取消必须有1个从节点强同步的逻辑。 业务可以正常写入

待从库重新启动后, 追平wal日志, 然后重新设置强制同步
```
#### monitor 节点故障

> 模拟 monitor 节点故障

```sh
systemctl stop pgmonitor5432
```

> 测试结果

```
不影响主从实例, 主节点依然可读写。 从节点依然可读
```

#### monitor 故障后, 从节点再故障

```
主节点会关闭数据库实例, 业务写入失败，等待集群恢复。

说明:
pgsql 主节点在联系不到 monitor 节点后, 会以是否有从节点正在连接作为后续动作的判断依据
如果有从节点连接到主节点，则无任何影响, 业务写入正常
如果没有从节点连接到主节点， 则主节点关闭数据库进程(防止网络分区导致的脑裂)
```

#### 从节点故障, 主节点再故障

> 模拟操作

```
停止从节点 systemctl stop pgdata5432
这时主节点等20秒后可以正常写入，等几分钟之后，
停止主节点 systemctl stop pgdata5432
```

> 测试结果

```
现在主和从节点都故障停止了, 客户端写入失败

恢复时, 如果首先启动从节点进程, monitor 会判断该节点处于 catchingup (追赶) 状态, 阻止进程启动
直到 pgsql 主节点启动后, 主节点依旧为主库运行,  从节点在主节点启动后进程也会正常启动成功, 并且也依旧作为从库运行。
```

#### 从节点同步失败时, 主节点故障

> 模拟操作

```
1. 从节点停库
2. 主节点多次切换 wal 日志文件之后, 产生检查点, 然后将检查点之前的 wal 日志文件全部删除
3. 从节点启动实例
4. 这时同步状态是异常状态, 由于接不上 wal 日志而无法同步
5. 此时, 停止主节点实例
```

> 测试结果

```
客户端写入全部失败
monitor 判断从节点处于 catchingup (追赶) 状态, 无法提升为主库。 
等待人为介入, 修复集群。 否则集群将一直不可用。

手动启动主节点后, 客户端写入恢复。
后续需要手动重做从节点实例, 不然从节点永远好不了
```

#### 从节点同步有延迟时, 主节点故障

> 模拟操作

```
1. 从节点停库, 20秒后会取消强制同步参数(synchronous_standby_names)
2. 取消强制同步后, 主节点进行大量写入操作(写入几小时)
3. 从节点启动, 查看主从同步会有延迟的情况
4. 这时停止主节点
```

> 测试结果

```
测试结果同上一个测试场景: 从节点同步失败时, 主节点故障

客户端写入全部失败
monitor 判断从节点处于 catchingup (追赶) 状态, 无法提升为主库。 

手动启动主节点后, 客户端写入恢复。 
并且等主从同步延迟不超过1个wal日志文件之后, 重新设置强制同步参数(synchronous_standby_names)
这时可能会导致短暂的延迟峰值，因为写入将阻塞，直到备用服务器赶上
```

### 网络故障

#### `pgsql 主节点` 访问不到 `monitor`

> 模拟操作

```sh
# 在 monitor 节点设置 iptables 规则
iptables -I INPUT -s 10.57.144.236/32 -p tcp --dport 5432 -j DROP
```

> 测试结果

```
如果有从节点连接到主节点，则无任何影响, 业务写入正常
如果没有从节点连接到主节点， 则主节点关闭数据库进程(防止网络分区导致的脑裂)
```

#### `monitor` 访问不到 `pgsql 主节点`

> 模拟操作

```sh
# 在 pgsql 主节点设置 iptables 规则
iptables -I INPUT -s 10.57.144.235/32 -p tcp --dport 5432 -j DROP
```

> 测试结果

```
monitor 标记 pgsql 主节点时添加 ！ 符号以表示有问题, 但不会触发切主动作
业务写入正常
```

#### `monitor` 和 `pgsql 主节`点相互都访问不到

> 模拟操作

```sh
# 在 pgsql 主节点设置 iptables 规则
iptables -I INPUT -s 10.57.144.235/32 -p tcp --dport 5432 -j DROP

# 在 monitor 节点执行 iptables 规则 
iptables -I INPUT -s 10.57.144.236/32 -p tcp --dport 5432 -j DROP
```

> 测试结果

```
产生切主操作, 并且 pg_autoctl 主进程会将原主库的 pgsql 实例停止运行。 直到与 monitor 节点的通信正常后, pg_autoctl 会自动启动 pgsql 数据库实例, 并做为从节点同步新主库

业务最开始 25 ~ 30 秒内写入正常,之后会出现 20秒左右的写入阻塞(卡住), 然后开始有10几秒的请求失败, 最后等切主完成后,开始写入正常。
总共影响 1分钟左右。
```

#### `pgsql 从节点` 访问不到 `monitor` 

```
无任何影响, 业务写入正常
```

#### `monitor` 访问不到 `pgsql 从节点` 

```
从节点标记加 ! 符号, 但不会切主, 也不影响业务使用
业务写入正常
```

#### `monitor` 和 `pgsql 从节点` 互相访问不到

```
从节点标记加 ! 符号, 并且标记为 catchingup(追赶) 状态, 无法成为主库。
但实际主从同步状态正常, 没有延迟。对数据没有影响。
业务写入正常, 无任何影响
```
