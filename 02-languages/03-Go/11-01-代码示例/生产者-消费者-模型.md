
```go
fanin.go

import "reflect"

// FanInRec 扇入模式
func FanInRec(channels ...<-chan interface{}) <-chan interface{} {
	out := make(chan interface{}, 1)
	go func() {
		defer close(out)
		var cases []reflect.SelectCase
		for _, channel := range channels {
			cases = append(cases, reflect.SelectCase{
				Dir:  reflect.SelectRecv,
				Chan: reflect.ValueOf(channel),
			})
		}
		for len(cases) > 0 {
			i, v, ok := reflect.Select(cases)
			if !ok {
				// 监控的channel已经关闭
				cases = append(cases[:i], cases[i+1:]...)
				continue
			}
			out <- v.Interface()
		}
	}()
	return out
}

// MergeChannel 合并两个channel
func MergeChannel(a, b <-chan interface{}) <-chan interface{} {
	c := make(chan interface{})
	go func() {
		defer close(c)
		for a != nil || b != nil {
			select {
			case v, ok := <-a:
				if !ok {
					a = nil
					continue
				}
				c <- v
			case v, ok := <-b:
				if !ok {
					b = nil
					continue
				}
				c <- v
			}
		}
	}()
	return c
}

```

```go
fanout.go

import "sync"

// FanOut 扇出模式
func FanOut(in <-chan interface{}, out []chan interface{}, async bool) {
	wg := sync.WaitGroup{}
	go func() {
		defer func() {
			wg.Wait()
			for i := 0; i < len(out); i++ {
				close(out[i])
			}
		}()
		for v := range in {
			for i := 0; i < len(out); i++ {
				if async {
					// 异步
					wg.Add(1)
					go func(ch chan interface{}, v interface{}) {
						defer wg.Done()
						ch <- v
					}(out[i], v)
				} else {
					// 同步
					out[i] <- v
				}
			}
		}
	}()
}
```


```go
map_reduce.go

package concurrent

func MapChan(in <-chan interface{}, fn func(interface{}) interface{}) <-chan interface{} {
	out := make(chan interface{}, 1)
	if in == nil {
		close(out)
		return out
	}
	go func() {
		defer close(out)
		for v := range in {
			out <- fn(v)
		}
	}()
	return out
}

func ReduceChan(in <-chan interface{}, fn func(r, v interface{}) interface{}) interface{} {
	if in == nil {
		return nil
	}
	out := <-in
	for v := range in {
		out = fn(out, v)
	}
	return out
}

```


```go
orderly.go

package concurrent

import "sync"

type WaitGroup interface {
	Add(int)
	Wait()
	Done()
	Do()
}

type OrderlyTask struct {
	sync.WaitGroup
	fn func()
}

// Do 执行任务
func (o *OrderlyTask) Do() {
	o.Add(1)
	go func() {
		defer o.Done()
		o.fn()
	}()
}

// NewOrderTask 初始化任务
func NewOrderTask(fn func()) *OrderlyTask {
	return &OrderlyTask{
		fn: fn,
	}
}

// Orderly 顺序执行
func Orderly(tasks []*OrderlyTask) {
	for _, task := range tasks {
		task.Do()
		task.Wait()
	}
}
```

```go
or_done.go

package concurrent

import "reflect"

// OrDone 任意channel完成后返回
func OrDone(channels ...<-chan interface{}) <-chan interface{} {
	switch len(channels) {
	case 0:
		// 返回已经关闭的channel 通知各个接受者关闭
		c := make(chan interface{})
		close(c)
		return c
	case 1:
		return channels[0]
	}
	orDone := make(chan interface{}, 1)
	go func() {
		defer close(orDone)
		var cases []reflect.SelectCase
		for _, channel := range channels {
			cases = append(cases, reflect.SelectCase{
				Dir:  reflect.SelectRecv,
				Chan: reflect.ValueOf(channel),
			})
		}
		// 选择一个可用的
		reflect.Select(cases)
	}()
	return orDone
}

```

```go
stream.go

package concurrent

import "context"

func Stream(ctx context.Context, values ...interface{}) <-chan interface{} {
	out := make(chan interface{})
	go func() {
		defer close(out)
		for _, value := range values {
			select {
			case <-ctx.Done():
				return
			case out <- value:
			}
		}
	}()
	return out
}

// TaskN 只取流中的前N个数据
func TaskN(ctx context.Context, valueStream <-chan interface{}, num int) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for i := 0; i < num; i++ {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				select {
				case <-ctx.Done():
					return
				case outStream <- v:

				}
			}
		}
	}()
	return outStream
}

// TaskFn 筛选流中的数据,只保留满足条件的数据
func TaskFn(ctx context.Context, valueStream <-chan interface{}, fn func(v interface{}) bool) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				if fn(v) {
					select {
					case <-ctx.Done():
						return
					case outStream <- v:
					}
				}
			}
		}
	}()
	return outStream
}

// TaskWhile 只取满足条件的数据,一旦不满足就不再取
func TaskWhile(ctx context.Context, valueStream <-chan interface{}, fn func(v interface{}) bool) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				if fn(v) {
					select {
					case <-ctx.Done():
						return
					case outStream <- v:
					}
					return
				}
			}
		}
	}()
	return outStream
}

// SkipN 跳过流中的前N个数据
func SkipN(ctx context.Context, valueStream <-chan interface{}, num int) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for i := 0; i < num; i++ {
			select {
			case <-ctx.Done():
				return
			case _, ok := <-valueStream:
				if !ok {
					return
				}
			}
		}
		for {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				select {
				case <-ctx.Done():
					return
				case outStream <- v:
				}
			}
		}
	}()
	return outStream
}

// SkipFn 跳过满足条件的数据
func SkipFn(ctx context.Context, valueStream <-chan interface{}, fn func(v interface{}) bool) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				if !fn(v) {
					select {
					case <-ctx.Done():
						return
					case outStream <- v:
					}
				}
			}
		}
	}()
	return outStream
}

// SkipWhile 跳过满足条件的数据,一旦不满足,当前这个元素以后的元素都会输出
func SkipWhile(ctx context.Context, valueStream <-chan interface{}, fn func(v interface{}) bool) <-chan interface{} {
	outStream := make(chan interface{})
	go func() {
		defer close(outStream)
		for {
			select {
			case <-ctx.Done():
				return
			case v, ok := <-valueStream:
				if !ok {
					return
				}
				if fn(v) {
					select {
					case <-ctx.Done():
						return
					default:

					}
				} else {
					select {
					case <-ctx.Done():
						return
					case outStream <- v:
					}
					for {
						select {
						case <-ctx.Done():
							return
						case v, ok = <-valueStream:
							if !ok {
								return
							}
							select {
							case <-ctx.Done():
								return
							case outStream <- v:
							}
						}
					}
				}
			}
		}
	}()
	return outStream
}
```


```go
pipeline.go 

package concurrent

// Pipeline 串联模式
func Pipeline(in chan interface{}) <-chan interface{} {
	out := make(chan interface{}, 1)
	go func() {
		for v := range in {
			out <- v
		}
	}()
	return out
}

```